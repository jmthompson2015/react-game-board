!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).ReactGameBoard=e()}(this,(function(){"use strict";const t=Math.PI/180,e=Math.cos(45*t),n=Math.sqrt(3),o=(t,e,n,o,i,r)=>(n-t)*(r-e)-(i-t)*(o-e);class i{constructor(t=!0,e=!0){this._isSquare=t,this._isFlat=e}get cornerCount(){return this.isSquare?4:6}get isFlat(){return this._isFlat}get isHexagon(){return!this._isSquare}get isPointy(){return!this._isFlat}get isSquare(){return this._isSquare}cellCorner(e,n,o){const i=this.isSquare?90:60,r=this.isSquare?.5:1;let s=0;this.isSquare&&this.isFlat&&(s=45),this.isHexagon&&this.isPointy&&(s=30);const a=t*(i*o-s);return Immutable({x:e.x+r*n*Math.cos(a),y:e.y+r*n*Math.sin(a)})}cellDimensions(t){let o,i;return this.isSquare&&this.isFlat?(o=2*e*t,i=2*e*t):this.isSquare&&this.isPointy?(o=2*t,i=2*t):this.isHexagon&&this.isFlat?(o=2*t,i=n*t):this.isHexagon&&this.isPointy&&(o=n*t,i=2*t),Immutable({w:o,h:i})}cellToPixel(t,o,i,r={x:0,y:0}){let s,a;return this.isSquare&&this.isFlat?(s=i*e*t,a=i*e*o):this.isSquare&&this.isPointy?(s=(i*t-i*o)/2,a=(i*t+i*o)/2):this.isHexagon&&this.isFlat?(s=i*(1.5*t),a=i*(n/2*t+n*o)):this.isHexagon&&this.isPointy&&(s=i*(n*t+n/2*o),a=i*(1.5*o)),Immutable({x:s+r.x,y:a+r.y})}computeCorners(t,e){const n=[];for(let o=0;o<this.cornerCount;o+=1){const i=this.cellCorner(t,e,o);n.push(i)}return n}}i.boundingBox=t=>{const e=R.map(R.prop("x"),t),n=R.map(R.prop("y"),t),o=Math.min(...e),i=Math.min(...n);return{x:o,y:i,width:Math.max(...e)-o,height:Math.max(...n)-i}},i.drawCell=(t,e,n,o)=>{const r=t;r.save(),r.lineJoin="miter",r.lineWidth=o,r.strokeStyle=n,i.enterPath(r,e),r.stroke(),r.restore()},i.drawCircularImage=(t,e,n)=>{const o=i.boundingBox(e),r=.9*Math.min(o.width,o.height),s=(o.width-r)/2,a=(o.height-r)/2;t.drawImage(n,o.x+s,o.y+a,r,r)},i.drawRectangularImage=(t,e,n)=>{const o=i.boundingBox(e);t.drawImage(n,o.x,o.y,o.width,o.height)},i.enterPath=(t,e)=>{t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let n=1;n<e.length;n+=1)t.lineTo(e[n].x,e[n].y);t.closePath()},i.fillCell=(t,e,n)=>{const o=t;o.save(),i.enterPath(o,e),o.fillStyle=n,o.fill(),o.restore()},i.isPointInPolygon=(t,e,n)=>{return((t,e,n)=>{let i=0;const r=(t=>{const e=[];for(let n=0;n<t.length;n+=1){const o=t[n];e.push(o.x),e.push(o.y)}const n=t[0];return e.push(n.x),e.push(n.y),e})(n),s=r.length-2;for(let n=0;n<s;n+=2)r[n+1]<=e?r[n+3]>e&&o(r[n],r[n+1],r[n+2],r[n+3],t,e)>0&&(i+=1):r[n+3]<=e&&o(r[n],r[n+1],r[n+2],r[n+3],t,e)<0&&(i-=1);return i})(t,e,n)%2!=0};const r=(t,e)=>{const n=String.fromCodePoint("a".codePointAt(0)+t-1);return e<"a"||e>n},s=(t,e)=>e<1||e>t,a=(t,e)=>{const n=String.fromCodePoint("A".codePointAt(0)+t-1);return e<"A"||e>n},l=(t,e)=>e<1||e>t,u=t=>null==t,c=(t,e)=>e<1||e>t;const h={createCube:({x:t=0,y:e=0,z:n=0}={})=>Immutable({x:t,y:e,z:n}),createDimension:({w:t=0,h:e=0}={})=>Immutable({w:t,h:e}),createHex:({q:t=0,r:e=0}={})=>Immutable({q:t,r:e}),createPoint:({x:t=0,y:e=0}={})=>Immutable({x:t,y:e})},d=[h.createCube({x:1,y:-1,z:0}),h.createCube({x:1,y:0,z:-1}),h.createCube({x:0,y:1,z:-1}),h.createCube({x:-1,y:1,z:0}),h.createCube({x:-1,y:0,z:1}),h.createCube({x:0,y:-1,z:1})],C=(t,e)=>h.createCube({x:t.x+e.x,y:t.y+e.y,z:t.z+e.z});h.axialToCube=t=>{const e=t.q,n=t.r,o=-e-n;return h.createCube({x:e,y:o,z:n})},h.cubeDirection=t=>d[t],h.cubeDistance=(t,e)=>(Math.abs(t.x-e.x)+Math.abs(t.y-e.y)+Math.abs(t.z-e.z))/2,h.cubeNeighbor=(t,e)=>C(t,h.cubeDirection(e)),h.cubeNeighbors=t=>{return R.reduce((e,n)=>R.append(C(t,n),e),[],d)},h.cubeToAxial=t=>{const e=t.x,n=t.z;return h.createHex({q:e,r:n})},h.hexDistance=(t,e)=>{const n=h.axialToCube(t),o=h.axialToCube(e);return h.cubeDistance(n,o)},h.hexNeighbor=(t,e)=>{const n=h.axialToCube(t),o=h.cubeNeighbor(n,e);return h.cubeToAxial(o)},h.hexNeighbors=t=>{const e=h.axialToCube(t),n=h.cubeNeighbors(e);return R.map(t=>h.cubeToAxial(t),n)};const m=t=>(e,n,o,i)=>{const r=t.cellDimensions(e),s=Immutable({x:r.w/2+n.x,y:r.h/2+n.y});return t.cellToPixel(o,i,e,s)},g=(t,e,n,o,r,s,a)=>(l,u,c)=>h=>{for(let d=1;d<=e.rankCount;d+=1)for(let C=1;C<=e.fileCount;C+=1){const g=e.fileRankToAN(C,d);if(a(g)){const e=m(t)(c,u,C-1,d-1),a=t.computeCorners(e,c),p=r(g);p&&i.fillCell(h,a,p);const f=s(g);if(f){const t=l[f];t&&i.drawRectangularImage(h,a,t)}i.drawCell(h,a,n,o)}}},p=(t,e,n,o,i)=>(r,s,a)=>l=>{l.save();for(let u=1;u<=e.rankCount;u+=1)for(let c=1;c<=e.fileCount;c+=1){const h=e.fileRankToAN(c,u);if(o(h)){const e=i[h],o=m(t)(a,s,c-1,u-1);n(l,o,a,h,e,r)}}l.restore()},f=(t,e)=>new Promise((n,o)=>{const i=new Image;i.addEventListener("load",()=>{e&&console.log(`Loaded image: ${t} ${i.width}x${i.height}`),n(i)}),i.addEventListener("error",t=>o(t)),i.src=t});class y extends React.PureComponent{constructor(t){super(t),this.state={imageMap:{},offset:Immutable({x:0,y:0}),size:1},this.handleOnClick=this.handleOnClickFunction.bind(this)}componentDidMount(){this.loadImages(),this.computeSize(),this.paint()}componentDidUpdate(){this.paint()}computeSize(){const{boardCalculator:t,coordinateCalculator:e,gridLineWidth:n,height:o,isCellUsedFunction:i,width:r}=this.props,{cornerCount:s}=t,a=Immutable({x:0,y:0});let l=Number.POSITIVE_INFINITY,u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let n=1;n<=e.rankCount;n+=1)for(let o=1;o<=e.fileCount;o+=1){if(i(e.fileRankToAN(o,n))){const e=m(t)(1,a,o-1,n-1);for(let n=0;n<s;n+=1){const o=t.cellCorner(e,1,n);l=Math.min(o.x,l),u=Math.min(o.y,u),c=Math.max(o.x,c),h=Math.max(o.y,h)}}}const d=c-l,C=h-u,g=(r-n)/d,p=(o-n)/C,f=Math.min(g,p),y=Immutable({x:(r-f*d)/2-f*l,y:(o-f*C)/2-f*u});this.setState({size:f,offset:y})}handleOnClickFunction(t){const{boardCalculator:e,coordinateCalculator:n,isCellUsedFunction:o,onClick:r}=this.props,{offset:s,size:a}=this.state,l=t.currentTarget.getBoundingClientRect(),u=Immutable({x:Math.round(t.clientX-l.left),y:Math.round(t.clientY-l.top)});let c=null;for(let t=1;!c&&t<=n.rankCount;t+=1)for(let r=1;!c&&r<=n.fileCount;r+=1){const l=n.fileRankToAN(r,t);if(o(l)){const n=m(e)(a,s,r-1,t-1),o=e.computeCorners(n,a);i.isPointInPolygon(u.x,u.y,o)&&(c=l)}}r(c)}loadImages(){const{images:t,isVerbose:e}=this.props;for(let n=0;n<t.length;n+=1)f(t[n],e).then(e=>{const{imageMap:o}=this.state;this.setState({imageMap:R.assoc(t[n],e,o)})})}paint(){const{anToTokens:t,boardCalculator:e,cellColorFunction:n,cellImageFunction:o,coordinateCalculator:i,customKey:r,drawTokenFunction:s,gridColor:a,gridLineWidth:l,height:u,isCellUsedFunction:c,width:h}=this.props,{imageMap:d,offset:C,size:m}=this.state,f=document.getElementById(r).getContext("2d");f.clearRect(0,0,h,u),g(e,i,a,l,n,o,c)(d,C,m)(f),p(e,i,s,c,t)(d,C,m)(f)}render(){const{backgroundColor:t,customKey:e,height:n,width:o}=this.props;return ReactDOMFactories.canvas({id:e,key:e,onClick:this.handleOnClick,style:{backgroundColor:t},width:o,height:n})}}return y.propTypes={anToTokens:PropTypes.shape().isRequired,boardCalculator:PropTypes.shape().isRequired,coordinateCalculator:PropTypes.shape().isRequired,drawTokenFunction:PropTypes.func.isRequired,backgroundColor:PropTypes.string,cellColorFunction:PropTypes.func,cellImageFunction:PropTypes.func,customKey:PropTypes.string,gridColor:PropTypes.string,gridLineWidth:PropTypes.number,height:PropTypes.number,images:PropTypes.arrayOf(PropTypes.string),isCellUsedFunction:PropTypes.func,isVerbose:PropTypes.bool,onClick:PropTypes.func,width:PropTypes.number},y.defaultProps={backgroundColor:"Gainsboro",cellColorFunction:()=>void 0,cellImageFunction:()=>void 0,customKey:"hexBoardCanvas",gridColor:"Black",gridLineWidth:1,height:480,images:[],isCellUsedFunction:()=>!0,isVerbose:!1,onClick:()=>{},width:640},y.BoardCalculator=i,y.CoordinateCalculator=class{constructor(t=8,e=8,n=1){this._fileCount=t,this._rankCount=e,this._levelCount=n}get fileCount(){return this._fileCount}get rankCount(){return this._rankCount}get levelCount(){return this._levelCount}anToFile(t){if(u(t))return null;const e=t.trim().charAt(0);return u(e)||r(this.fileCount,e)?null:e.codePointAt(0)-"a".codePointAt(0)+1}anToIndex(t){if(u(t))return null;const e=this.anToFile(t),n=this.anToRank(t),o=this.anToLevel(t);return u(e)||u(n)?null:u(o)?(n-1)*this.fileCount+(e-1):(o-1)*this.rankCount*this.fileCount+(n-1)*this.fileCount+(e-1)}anToLevel(t){if(u(t))return null;const e=t.trim(),n=e.charAt(e.length-1);return u(n)||a(this.levelCount,n)?null:n.codePointAt(0)-"A".codePointAt(0)+1}anToRank(t){if(u(t))return null;const e=parseInt(t.trim().substring(1),10);return c(this.rankCount,e)?null:e}fileRankToAN(t,e){if(s(this.fileCount,t)||c(this.rankCount,e))return null;const n=String.fromCodePoint("a".codePointAt(0)+t-1);return u(n)||r(this.fileCount,n)?null:`${n}${e}`}fileRankLevelToAN(t,e,n){if(s(this.fileCount,t)||c(this.rankCount,e)||l(this.levelCount,n))return null;const o=String.fromCodePoint("a".codePointAt(0)+t-1);if(u(o)||r(this.fileCount,o))return null;const i=String.fromCodePoint("A".codePointAt(0)+n-1);return u(i)||a(this.levelCount,i)?null:`${o}${e}${i}`}},y.HexBoardUtilities=h,y}));
