!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).ReactGameBoard=e()}(this,(function(){"use strict";const t=Math.PI/180,e=Math.cos(45*t),o=Math.sqrt(3),n=(t,e,o,n,i,r)=>(o-t)*(r-e)-(i-t)*(n-e);class i{constructor(t=!0,e=!0){this._isSquare=t,this._isFlat=e}get cornerCount(){return this.isSquare?4:6}get isFlat(){return this._isFlat}get isHexagon(){return!this._isSquare}get isPointy(){return!this._isFlat}get isSquare(){return this._isSquare}cellCorner(e,o,n){const i=this.isSquare?90:60,r=this.isSquare?.5:1;let s=0;this.isSquare&&this.isFlat&&(s=45),this.isHexagon&&this.isPointy&&(s=30);const a=t*(i*n-s);return Immutable({x:e.x+r*o*Math.cos(a),y:e.y+r*o*Math.sin(a)})}cellDimensions(t){let n,i;return this.isSquare&&this.isFlat?(n=2*e*t,i=2*e*t):this.isSquare&&this.isPointy?(n=2*t,i=2*t):this.isHexagon&&this.isFlat?(n=2*t,i=o*t):this.isHexagon&&this.isPointy&&(n=o*t,i=2*t),Immutable({w:n,h:i})}cellToPixel(t,n,i,r={x:0,y:0}){let s,a;return this.isSquare&&this.isFlat?(s=i*e*t,a=i*e*n):this.isSquare&&this.isPointy?(s=(i*t-i*n)/2,a=(i*t+i*n)/2):this.isHexagon&&this.isFlat?(s=i*(1.5*t),a=i*(o/2*t+o*n)):this.isHexagon&&this.isPointy&&(s=i*(o*t+o/2*n),a=i*(1.5*n)),Immutable({x:s+r.x,y:a+r.y})}computeCorners(t,e){const o=[];for(let n=0;n<this.cornerCount;n+=1){const i=this.cellCorner(t,e,n);o.push(i)}return o}}i.boundingBox=t=>{const e=R.map(R.prop("x"),t),o=R.map(R.prop("y"),t),n=Math.min(...e),i=Math.min(...o);return{x:n,y:i,width:Math.max(...e)-n,height:Math.max(...o)-i}},i.drawCell=(t,e,o,n)=>{const r=t;r.save(),r.lineJoin="miter",r.lineWidth=n,r.strokeStyle=o,i.enterPath(r,e),r.stroke(),r.restore()},i.drawCircularImage=(t,e,o)=>{const n=i.boundingBox(e),r=.9*Math.min(n.width,n.height),s=(n.width-r)/2,a=(n.height-r)/2;t.drawImage(o,n.x+s,n.y+a,r,r)},i.drawRectangularImage=(t,e,o)=>{const n=i.boundingBox(e);t.drawImage(o,n.x,n.y,n.width,n.height)},i.enterPath=(t,e)=>{t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let o=1;o<e.length;o+=1)t.lineTo(e[o].x,e[o].y);t.closePath()},i.fillCell=(t,e,o)=>{const n=t;n.save(),i.enterPath(n,e),n.fillStyle=o,n.fill(),n.restore()},i.isPointInPolygon=(t,e,o)=>{return((t,e,o)=>{let i=0;const r=(t=>{const e=[];for(let o=0;o<t.length;o+=1){const n=t[o];e.push(n.x),e.push(n.y)}const o=t[0];return e.push(o.x),e.push(o.y),e})(o),s=r.length-2;for(let o=0;o<s;o+=2)r[o+1]<=e?r[o+3]>e&&n(r[o],r[o+1],r[o+2],r[o+3],t,e)>0&&(i+=1):r[o+3]<=e&&n(r[o],r[o+1],r[o+2],r[o+3],t,e)<0&&(i-=1);return i})(t,e,o)%2!=0};const r=(t,e)=>{const o=String.fromCodePoint("a".codePointAt(0)+t-1);return e<"a"||e>o},s=(t,e)=>e<1||e>t,a=(t,e)=>{const o=String.fromCodePoint("A".codePointAt(0)+t-1);return e<"A"||e>o},l=(t,e)=>e<1||e>t,u=t=>null==t,c=(t,e)=>e<1||e>t;const h={createCube:({x:t=0,y:e=0,z:o=0}={})=>Immutable({x:t,y:e,z:o}),createDimension:({w:t=0,h:e=0}={})=>Immutable({w:t,h:e}),createHex:({q:t=0,r:e=0}={})=>Immutable({q:t,r:e}),createPoint:({x:t=0,y:e=0}={})=>Immutable({x:t,y:e})},d=[h.createCube({x:1,y:-1,z:0}),h.createCube({x:1,y:0,z:-1}),h.createCube({x:0,y:1,z:-1}),h.createCube({x:-1,y:1,z:0}),h.createCube({x:-1,y:0,z:1}),h.createCube({x:0,y:-1,z:1})],C=(t,e)=>h.createCube({x:t.x+e.x,y:t.y+e.y,z:t.z+e.z});h.axialToCube=t=>{const e=t.q,o=t.r,n=-e-o;return h.createCube({x:e,y:n,z:o})},h.cubeDirection=t=>d[t],h.cubeNeighbor=(t,e)=>C(t,h.cubeDirection(e)),h.cubeNeighbors=t=>{return R.reduce((e,o)=>R.append(C(t,o),e),[],d)},h.cubeToAxial=t=>{const e=t.x,o=t.z;return h.createHex({q:e,r:o})},h.hexNeighbor=(t,e)=>{const o=h.axialToCube(t),n=h.cubeNeighbor(o,e);return h.cubeToAxial(n)},h.hexNeighbors=t=>{const e=h.axialToCube(t),o=h.cubeNeighbors(e);return R.map(t=>h.cubeToAxial(t),o)};const m=(t,e)=>new Promise((o,n)=>{const i=new Image;i.addEventListener("load",()=>{e&&console.log(`Loaded image: ${t} ${i.width}x${i.height}`),o(i)}),i.addEventListener("error",t=>n(t)),i.src=t});class p extends React.PureComponent{constructor(t){super(t),this.state={imageMap:{},offset:Immutable({x:0,y:0}),size:1},this.handleOnClick=this.handleOnClickFunction.bind(this)}componentDidMount(){this.loadImages(),this.computeSize(),this.paint()}componentDidUpdate(){this.paint()}computeCenter(t,e,o,n){const{boardCalculator:i}=this.props,r=i.cellDimensions(t),s=Immutable({x:r.w/2+e.x,y:r.h/2+e.y});return i.cellToPixel(o,n,t,s)}computeSize(){const{boardCalculator:t,coordinateCalculator:e,gridLineWidth:o,height:n,isCellUsedFunction:i,width:r}=this.props,{cornerCount:s}=t,a=Immutable({x:0,y:0});let l=Number.POSITIVE_INFINITY,u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let o=1;o<=e.rankCount;o+=1)for(let n=1;n<=e.fileCount;n+=1){if(i(e.fileRankToAN(n,o))){const e=this.computeCenter(1,a,n-1,o-1);for(let o=0;o<s;o+=1){const n=t.cellCorner(e,1,o);l=Math.min(n.x,l),u=Math.min(n.y,u),c=Math.max(n.x,c),h=Math.max(n.y,h)}}}const d=c-l,C=h-u,m=(r-o)/d,p=(n-o)/C,g=Math.min(m,p),f=Immutable({x:(r-g*d)/2-g*l,y:(n-g*C)/2-g*u});this.setState({size:g,offset:f})}drawCells(t){const{boardCalculator:e,coordinateCalculator:o,gridColor:n,gridLineWidth:r,cellColorFunction:s,cellImageFunction:a,isCellUsedFunction:l}=this.props,{imageMap:u,offset:c,size:h}=this.state;for(let d=1;d<=o.rankCount;d+=1)for(let C=1;C<=o.fileCount;C+=1){const m=o.fileRankToAN(C,d);if(l(m)){const o=this.computeCenter(h,c,C-1,d-1),l=e.computeCorners(o,h),p=s(m);p&&i.fillCell(t,l,p);const g=a(m);if(g){const e=u[g];e&&i.drawRectangularImage(t,l,e)}i.drawCell(t,l,n,r)}}}drawTokens(t){const{coordinateCalculator:e,drawTokenFunction:o,isCellUsedFunction:n,anToTokens:i}=this.props,{imageMap:r,offset:s,size:a}=this.state;t.save();for(let l=1;l<=e.rankCount;l+=1)for(let u=1;u<=e.fileCount;u+=1){const c=e.fileRankToAN(u,l);if(n(c)){const e=i[c];o(t,this.computeCenter(a,s,u-1,l-1),a,c,e,r)}}t.restore()}handleOnClickFunction(t){const{boardCalculator:e,coordinateCalculator:o,isCellUsedFunction:n,onClick:r}=this.props,{offset:s,size:a}=this.state,l=t.currentTarget.getBoundingClientRect(),u=Immutable({x:Math.round(t.clientX-l.left),y:Math.round(t.clientY-l.top)});let c=null;for(let t=1;!c&&t<=o.rankCount;t+=1)for(let r=1;!c&&r<=o.fileCount;r+=1){const l=o.fileRankToAN(r,t);if(n(l)){const o=this.computeCenter(a,s,r-1,t-1),n=e.computeCorners(o,a);i.isPointInPolygon(u.x,u.y,n)&&(c=l)}}r(c)}loadImages(){const{images:t,isVerbose:e}=this.props;for(let o=0;o<t.length;o+=1)m(t[o],e).then(e=>{const{imageMap:n}=this.state;this.setState({imageMap:R.assoc(t[o],e,n)})})}paint(){const{height:t,myKey:e,width:o}=this.props,n=document.getElementById(e).getContext("2d");n.clearRect(0,0,o,t),this.drawCells(n),this.drawTokens(n)}render(){const{backgroundColor:t,height:e,myKey:o,width:n}=this.props;return ReactDOMFactories.canvas({id:o,key:o,onClick:this.handleOnClick,style:{backgroundColor:t},width:n,height:e})}}return p.propTypes={anToTokens:PropTypes.shape().isRequired,boardCalculator:PropTypes.shape().isRequired,coordinateCalculator:PropTypes.shape().isRequired,drawTokenFunction:PropTypes.func.isRequired,backgroundColor:PropTypes.string,cellColorFunction:PropTypes.func,cellImageFunction:PropTypes.func,gridColor:PropTypes.string,gridLineWidth:PropTypes.number,height:PropTypes.number,images:PropTypes.arrayOf(PropTypes.string),isCellUsedFunction:PropTypes.func,isVerbose:PropTypes.bool,myKey:PropTypes.string,onClick:PropTypes.func,width:PropTypes.number},p.defaultProps={backgroundColor:"Gainsboro",cellColorFunction:()=>void 0,cellImageFunction:()=>void 0,gridColor:"Black",gridLineWidth:1,height:480,images:[],isCellUsedFunction:()=>!0,isVerbose:!1,myKey:"hexBoardCanvas",onClick:()=>{},width:640},p.BoardCalculator=i,p.CoordinateCalculator=class{constructor(t=8,e=8,o=1){this._fileCount=t,this._rankCount=e,this._levelCount=o}get fileCount(){return this._fileCount}get rankCount(){return this._rankCount}get levelCount(){return this._levelCount}anToFile(t){if(u(t))return null;const e=t.trim().charAt(0);return u(e)||r(this.fileCount,e)?null:e.codePointAt(0)-"a".codePointAt(0)+1}anToIndex(t){if(u(t))return null;const e=this.anToFile(t),o=this.anToRank(t),n=this.anToLevel(t);return u(e)||u(o)?null:u(n)?(o-1)*this.fileCount+(e-1):(n-1)*this.rankCount*this.fileCount+(o-1)*this.fileCount+(e-1)}anToLevel(t){if(u(t))return null;const e=t.trim(),o=e.charAt(e.length-1);return u(o)||a(this.levelCount,o)?null:o.codePointAt(0)-"A".codePointAt(0)+1}anToRank(t){if(u(t))return null;const e=parseInt(t.trim().substring(1),10);return c(this.rankCount,e)?null:e}fileRankToAN(t,e){if(s(this.fileCount,t)||c(this.rankCount,e))return null;const o=String.fromCodePoint("a".codePointAt(0)+t-1);return u(o)||r(this.fileCount,o)?null:`${o}${e}`}fileRankLevelToAN(t,e,o){if(s(this.fileCount,t)||c(this.rankCount,e)||l(this.levelCount,o))return null;const n=String.fromCodePoint("a".codePointAt(0)+t-1);if(u(n)||r(this.fileCount,n))return null;const i=String.fromCodePoint("A".codePointAt(0)+o-1);return u(i)||a(this.levelCount,i)?null:`${n}${e}${i}`}},p.HexBoardUtilities=h,p}));
