!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).ReactGameBoard=e()}(this,(function(){"use strict";const t=Math.PI/180,e=Math.cos(45*t),n=Math.sqrt(3),o=(t,e,n,o,i,s)=>(n-t)*(s-e)-(i-t)*(o-e);class i{constructor(t=!0,e=!0){this._isSquare=t,this._isFlat=e}get cornerCount(){return this.isSquare?4:6}get isFlat(){return this._isFlat}get isHexagon(){return!this._isSquare}get isPointy(){return!this._isFlat}get isSquare(){return this._isSquare}cellCorner(e,n,o){const i=this.isSquare?90:60,s=this.isSquare?.5:1;let r=0;this.isSquare&&this.isFlat&&(r=45),this.isHexagon&&this.isPointy&&(r=30);const l=t*(i*o-r);return Immutable({x:e.x+s*n*Math.cos(l),y:e.y+s*n*Math.sin(l)})}cellDimensions(t){let o,i;return this.isSquare&&this.isFlat?(o=2*e*t,i=2*e*t):this.isSquare&&this.isPointy?(o=2*t,i=2*t):this.isHexagon&&this.isFlat?(o=2*t,i=n*t):this.isHexagon&&this.isPointy&&(o=n*t,i=2*t),Immutable({w:o,h:i})}cellToPixel(t,o,i,s={x:0,y:0}){let r,l;return this.isSquare&&this.isFlat?(r=i*e*t,l=i*e*o):this.isSquare&&this.isPointy?(r=(i*t-i*o)/2,l=(i*t+i*o)/2):this.isHexagon&&this.isFlat?(r=i*(1.5*t),l=i*(n/2*t+n*o)):this.isHexagon&&this.isPointy&&(r=i*(n*t+n/2*o),l=i*(1.5*o)),Immutable({x:r+s.x,y:l+s.y})}computeCorners(t,e){const n=[];for(let o=0;o<this.cornerCount;o+=1){const i=this.cellCorner(t,e,o);n.push(i)}return n}}i.boundingBox=t=>{const e=R.map(R.prop("x"),t),n=R.map(R.prop("y"),t),o=Math.min(...e),i=Math.min(...n);return{x:o,y:i,width:Math.max(...e)-o,height:Math.max(...n)-i}},i.drawCell=(t,e,n,o)=>{const s=t;s.save(),s.lineJoin="miter",s.lineWidth=o,s.strokeStyle=n,i.enterPath(s,e),s.stroke(),s.restore()},i.drawCircularImage=(t,e,n)=>{const o=i.boundingBox(e),s=.9*Math.min(o.width,o.height),r=(o.width-s)/2,l=(o.height-s)/2;t.drawImage(n,o.x+r,o.y+l,s,s)},i.drawRectangularImage=(t,e,n)=>{const o=i.boundingBox(e);t.drawImage(n,o.x,o.y,o.width,o.height)},i.enterPath=(t,e)=>{t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let n=1;n<e.length;n+=1)t.lineTo(e[n].x,e[n].y);t.closePath()},i.fillCell=(t,e,n)=>{const o=t;o.save(),i.enterPath(o,e),o.fillStyle=n,o.fill(),o.restore()},i.isPointInPolygon=(t,e,n)=>{return((t,e,n)=>{let i=0;const s=(t=>{const e=[];for(let n=0;n<t.length;n+=1){const o=t[n];e.push(o.x),e.push(o.y)}const n=t[0];return e.push(n.x),e.push(n.y),e})(n),r=s.length-2;for(let n=0;n<r;n+=2)s[n+1]<=e?s[n+3]>e&&o(s[n],s[n+1],s[n+2],s[n+3],t,e)>0&&(i+=1):s[n+3]<=e&&o(s[n],s[n+1],s[n+2],s[n+3],t,e)<0&&(i-=1);return i})(t,e,n)%2!=0};const s=(t,e)=>{const n=String.fromCodePoint("a".codePointAt(0)+t-1);return e<"a"||e>n},r=(t,e)=>e<1||e>t,l=(t,e)=>{const n=String.fromCodePoint("A".codePointAt(0)+t-1);return e<"A"||e>n},a=(t,e)=>e<1||e>t,u=t=>null==t,c=(t,e)=>e<1||e>t;const h=(t,e)=>new Promise((n,o)=>{const i=new Image;i.addEventListener("load",()=>{e&&console.log(`Loaded image: ${t} ${i.width}x${i.height}`),n(i)}),i.addEventListener("error",t=>o(t)),i.src=t});class d extends React.PureComponent{constructor(t){super(t),this.state={imageMap:{},offset:Immutable({x:0,y:0}),size:1},this.handleOnClick=this.handleOnClickFunction.bind(this)}componentDidMount(){this.loadImages(),this.computeSize(),this.paint()}componentDidUpdate(){this.paint()}computeCenter(t,e,n,o){const{boardCalculator:i}=this.props,s=i.cellDimensions(t),r=Immutable({x:s.w/2+e.x,y:s.h/2+e.y});return i.cellToPixel(n,o,t,r)}computeSize(){const{boardCalculator:t,coordinateCalculator:e,gridLineWidth:n,height:o,isCellUsedFunction:i,width:s}=this.props,{cornerCount:r}=t,l=Immutable({x:0,y:0});let a=Number.POSITIVE_INFINITY,u=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,h=Number.NEGATIVE_INFINITY;for(let n=1;n<=e.rankCount;n+=1)for(let o=1;o<=e.fileCount;o+=1){if(i(e.fileRankToAN(o,n))){const e=this.computeCenter(1,l,o-1,n-1);for(let n=0;n<r;n+=1){const o=t.cellCorner(e,1,n);a=Math.min(o.x,a),u=Math.min(o.y,u),c=Math.max(o.x,c),h=Math.max(o.y,h)}}}const d=c-a,C=h-u,p=(s-n)/d,m=(o-n)/C,f=Math.min(p,m),g=Immutable({x:(s-f*d)/2-f*a,y:(o-f*C)/2-f*u});this.setState({size:f,offset:g})}drawCells(t){const{boardCalculator:e,coordinateCalculator:n,gridColor:o,gridLineWidth:s,cellColorFunction:r,cellImageFunction:l,isCellUsedFunction:a}=this.props,{imageMap:u,offset:c,size:h}=this.state;for(let d=1;d<=n.rankCount;d+=1)for(let C=1;C<=n.fileCount;C+=1){const p=n.fileRankToAN(C,d);if(a(p)){const n=this.computeCenter(h,c,C-1,d-1),a=e.computeCorners(n,h),m=r(p);m&&i.fillCell(t,a,m);const f=l(p);if(f){const e=u[f];e&&i.drawRectangularImage(t,a,e)}i.drawCell(t,a,o,s)}}}drawTokens(t){const{coordinateCalculator:e,drawTokenFunction:n,isCellUsedFunction:o,anToTokens:i}=this.props,{imageMap:s,offset:r,size:l}=this.state;t.save();for(let a=1;a<=e.rankCount;a+=1)for(let u=1;u<=e.fileCount;u+=1){const c=e.fileRankToAN(u,a);if(o(c)){const e=i[c];n(t,this.computeCenter(l,r,u-1,a-1),l,c,e,s)}}t.restore()}handleOnClickFunction(t){const{boardCalculator:e,coordinateCalculator:n,isCellUsedFunction:o,onClick:s}=this.props,{offset:r,size:l}=this.state,a=t.currentTarget.getBoundingClientRect(),u=Immutable({x:Math.round(t.clientX-a.left),y:Math.round(t.clientY-a.top)});let c=null;for(let t=1;!c&&t<=n.rankCount;t+=1)for(let s=1;!c&&s<=n.fileCount;s+=1){const a=n.fileRankToAN(s,t);if(o(a)){const n=this.computeCenter(l,r,s-1,t-1),o=e.computeCorners(n,l);i.isPointInPolygon(u.x,u.y,o)&&(c=a)}}s(c)}loadImages(){const{images:t,isVerbose:e}=this.props;for(let n=0;n<t.length;n+=1)h(t[n],e).then(e=>{const{imageMap:o}=this.state;this.setState({imageMap:R.assoc(t[n],e,o)})})}paint(){const{height:t,myKey:e,width:n}=this.props,o=document.getElementById(e).getContext("2d");o.clearRect(0,0,n,t),this.drawCells(o),this.drawTokens(o)}render(){const{backgroundColor:t,height:e,myKey:n,width:o}=this.props;return ReactDOMFactories.canvas({id:n,key:n,onClick:this.handleOnClick,style:{backgroundColor:t},width:o,height:e})}}return d.propTypes={anToTokens:PropTypes.shape().isRequired,boardCalculator:PropTypes.shape().isRequired,coordinateCalculator:PropTypes.shape().isRequired,drawTokenFunction:PropTypes.func.isRequired,backgroundColor:PropTypes.string,cellColorFunction:PropTypes.func,cellImageFunction:PropTypes.func,gridColor:PropTypes.string,gridLineWidth:PropTypes.number,height:PropTypes.number,images:PropTypes.arrayOf(PropTypes.string),isCellUsedFunction:PropTypes.func,isVerbose:PropTypes.bool,myKey:PropTypes.string,onClick:PropTypes.func,width:PropTypes.number},d.defaultProps={backgroundColor:"Gainsboro",cellColorFunction:()=>void 0,cellImageFunction:()=>void 0,gridColor:"Black",gridLineWidth:1,height:480,images:[],isCellUsedFunction:()=>!0,isVerbose:!1,myKey:"hexBoardCanvas",onClick:()=>{},width:640},d.BoardCalculator=i,d.CoordinateCalculator=class{constructor(t=8,e=8,n=1){this._fileCount=t,this._rankCount=e,this._levelCount=n}get fileCount(){return this._fileCount}get rankCount(){return this._rankCount}get levelCount(){return this._levelCount}anToFile(t){if(u(t))return null;const e=t.trim().charAt(0);return u(e)||s(this.fileCount,e)?null:e.codePointAt(0)-"a".codePointAt(0)+1}anToIndex(t){if(u(t))return null;const e=this.anToFile(t),n=this.anToRank(t),o=this.anToLevel(t);return console.log(`file=${e} rank=${n} level=${o}`),u(e)||u(n)?null:u(o)?(n-1)*this.fileCount+(e-1):(o-1)*this.rankCount*this.fileCount+(n-1)*this.fileCount+(e-1)}anToLevel(t){if(u(t))return null;const e=t.trim(),n=e.charAt(e.length-1);return u(n)||l(this.levelCount,n)?null:n.codePointAt(0)-"A".codePointAt(0)+1}anToRank(t){if(u(t))return null;const e=parseInt(t.trim().substring(1));return c(this.rankCount,e)?null:e}fileRankToAN(t,e){if(r(this.fileCount,t)||c(this.rankCount,e))return null;const n=String.fromCodePoint("a".codePointAt(0)+t-1);return u(n)||s(this.fileCount,n)?null:`${n}${e}`}fileRankLevelToAN(t,e,n){if(r(this.fileCount,t)||c(this.rankCount,e)||a(this.levelCount,n))return null;const o=String.fromCodePoint("a".codePointAt(0)+t-1);if(u(o)||s(this.fileCount,o))return null;const i=String.fromCodePoint("A".codePointAt(0)+n-1);return u(i)||l(this.levelCount,i)?null:`${o}${e}${i}`}},d}));
